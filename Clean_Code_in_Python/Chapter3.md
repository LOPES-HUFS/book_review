# Chapter3: 좋은 코드의 일반적인 특징

좋은 소프트웨어는 좋은 디자인으로부터 나온다. 코드를 가능한 견고하고 결함을 최소화하고 완전히 자명하도록 만드는 것이 클린 코드의 목표이다. 이런 목표를 위해 몇가지 원칙이 있다. 이 원칙들에 대해 살펴보자.

## 계약에 의한 디자인

고객에게 노출되는 API(Application Programmimg Interface)를 디자인할 때 예상되는 입력, 출력 및 부작용에 대해 문서화를 해야한다. 문서화가 소프트웨어의 동작을 강제할 수는 없다. 따라서 코드가 정상 작동하기 위해 기대하는 것과 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 된다. 코드 작동과 반환이라는 양쪽의 기대가 곧 계약이라는 개념을 만든다.

계약이란 양측이 동의하는 계약을 먼저 한 다음에 계약을 어겼을 경우 왜 계속 진행할 수 없는지 예외를 발생시키는 것이다. 계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술한다.

사전조건(precondition): 코드가 실행되기 전에 체크해야 하는 것들이다. 함수가 진행되기 전에 처리되어야 하는 모든 조건을 체크한다. 일반적으로 파라미터에 제공된 데이터의 유효성을 검사한다.

사후조건(postcondition): 사전조건과 반대로 여기서는 함수 반환 값의 유효성 검사를 수행한다. 호출자가 이 컴포넌트(모듈)에서 기대하는 것을 제대로 받았는지 확인하기 위해 수행한다.

불변식(invariant): 불변식은 함수가 실행되는 동안에 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것이다.

부작용(side-effect): 코드의 부작용을 docstring에 언급하기도 한다.

계약에 의한 디자인을 하는 이유는 오류 발생 시 쉽게 찾아낼 수 있기 때문이다. 사전 및 사후조건 검증은 오류를 쉽게 찾아 수정할 수 있다. 또한, 잘 못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지하기 위해서이다. 사전조건 검증에 실패하면 클라이언트의 결함에 의한 것이다. 사후조건 검증에 실패하면 특정 모듈이나 제공 클래스 자체의 문제가 있음을 알 수 있다.

### 사전조건과 사후조건

사전조건: 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것을 말한다. 프로그래밍에서 많이 사용되는 일반적인 용어로 적절한 데이터를 전달하는 것이다.

사전조건 검증은 타입 체킹과는 다르다. 필요로 하는 값이 정확한지를 검사하는 것이다. 유효성 검사를 언제할지에 따라 관용적인 접근법과 까다로운 접근 방법으로 나누어진다.

관용적 접근 방법: 클라이언트가 함수를 호출하기 전에 모든 유효성 검사를 하는 방법
까다로운 접근 방법: 함수가 자체적으로 로직을 실행하기 전에 검사하도록 하는 방법

일반적으로 계약에 의한 설계(DbC)에 대한 까다로운 접근법이 가장 안전하고 견고한 방법이며 널리 사용된다.

위의 두 가지 중 어떤 방식을 택하든 중복 제거 원칙을 항상 마음속에 간직해야한다. 중복 제거 원칙은 사전조건 검증을 양쪽에서 하지 말고 오직 어느 한쪽에서만 해야 한다는 것이다.

사후조건: 메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부이다.
사전조건이 맞는다면 사후조건은 반환 값의 특정 속서이 보존되도록 보장되어야 한다.
사후조건을 사용하여 클라이언트가 필요로 하는 모든 것을 검사할 수 있다.

파이썬스러운 계약: 메서드, 함수 및 클래스에 RuntimeError 예외 또는 ValueError 예외를 발생시키는 제어 메커니즘을 추가하는 것이다. 가장 일반적인 예외이지만 문제를 정확하게 특정하기 어려우면 사용자 정의 예외를 만드는 것이 가장 좋다.

계약에 의한 디자인 원칙에 따르게 되면 코드가 더욱 견고해진다. 또한 계약은 프로그램의 구조를 명확히 하는 목적으로도 사용된다. 명시적으로 함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지, 무엇을 기대할 수 있는지를 정의한다.

## 방어적 프로그래밍

방어적 프로그래밍은 계약과는 다른 접근 방식으로 객체, 함수 또는 메서드와 같은 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있게 하는 것이다. 방어적 프로그래밍의 주요 주제는 예상할 수 있는 시나리오의 오류를 처리하는 방법과 발생하지 않아야 하는 오류를 처리하는 방법에 대한 것이다.

### 에러 핸들링

에러 핸들링의 주요 목적은 예상되는 에러에 대해서 실행을 계속할 수 있을지 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것이다.

에러 처리 방법 3가지 - 값 대체, 에러 로깅, 예외 처리

값 대체: 일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있을 경우 결과 값을 안전한 다른 값으로 대체할 수 있다. 잘못된 결과를 정합성을 깨지 않는 안전한 다른 값으로 대체할 수 있다.

그러나 값 대체는 항상 가능하지는 않다. 대체 값이 실제로 안전한 옵션인 경우에 한해 신중하게 선택해 대체해야 한다. 이 결정은 견고성과 정확성 간의 트레이드 오프이다. 제공되지 않은 데이터에 기본 값을 사용하는 것이 안전한 방법이다. 설정되지 않은 환경 변수의 기본 값, 설정 파일의 누락된 항목 또는 함수의 파라미터와 같은 것들은 기본 값으로 동작이 가능한 것들이다.

```python
configuration = {"dbport ": 5432}
configuration.get("dbhost","localhost")
configuration.get("dbport ")

import os
os.getenv("DBHOST","localhost")
os.getenv("DPORT",5432)
```

예외처리 메커니즘

그러나 입력이 잘못되었을 때만 함수에 문제가 생기는 것은 아니다. 함수는 단순히 데이터를 전달받는 것이 아니라 외부 컴포넌트에 연결되어 있으며 부작용 또한 가지고 있다. 함수 호출 실패는 함수 자체의 문제가 아니라 이러한 외부 컴포넌트 중 하나의 문제로 인한 것일 수 있다. 이런 경우 적절하게 인터페이스를 설계하면 쉽게 디버깅할 수 있다. 함수는 심각한 오류에 대해 명확하고 분명하게 알려줘서 적절하게 해결할 수 있도록 해야한다. 예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것이 중요하다.

예외는 대개 호출자에게 잘못을 알려주는 것이다. 예외는 캡슐화를 약화시키기 때문에 신중하게 사용해야한다. 함수에 예외가 많을수록 호출자가 호출하는 함수에 대해 더 많은 것을 알아야만 한다. 그리고 함수가 너무 많은 예외를 발생시키면 문맥에서 자유롭지 않다는 것을 의미한다. 호출 시 발생 가능한 부작용 때문에

파이썬에서 traceback은 매우 유용하고 많은 디버깅 정보를 포함한다. 안타깝게도 이 정보는 악의적인 사용자에게도 매우 유용한 정보여서 중요 정보나 지적 재산의 유출이 발생할 위험이 있다.

비어있는 except 블록 지양: 비어 있는 경우 절대 실패하지 않기 때문에 실패해야만 하는 부분에서조차도 에러는 조용히 전달되어서는 안된다는 파이썬의 철학을 떠올리면 파이썬 스러운 코드가 아니다. 이에 대안으로는 보다 구체적인 예외를 사용하는 것, except 블록에서 실제 오류를 처리하는 것이다.

### 파이썬에서 어썰션 사용하기

어썰션은 절대로 일어나지 않아야 하는 상황에 사용되므로 assert 문에 사용된 표현식은 불가능한 조건을 의미한다. 이 상태가 된다는 건 소프트웨어의 결함이 있음을 의미한다. 에러 핸들링과 다르게 여기서는 프로그램을 계속할 또는 중단할 가능성이 있다. AssertionError는 예외 처리하지 않는다. 어설션에 실패하면 반드시 프로그램을 종료시켜야 한다.

## 관심사의 분리

프로그램의 각 부분은 기능의 일부분에 대해서만 책임을 지며 나머지 부분에 대해서는 알 필요가 없다. 관심사 분리의 목표는 파급 효과를 최소화하여 유지보수성을 향상시키는 것이다.

### 응집력과 결합력

응집력이란 객체가 작고 잘 정의된 목적을 가져야 하며 가능하면 작아야 한다는 것을 의미한다. 응집력이 높을수록 더 유용하고 재사용성이 높아지므로 더 좋은 디자인이다.
결합력이란 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타낸다. 객체 또는 메서드의 두 부분이 서로 너무 의존적이라면 낮은 재사용성, 파급 효과 낮은 수준 추상화 문제가 발생한다.
낮은 재사용성: 만약 어떤 함수가 특정 객체에 지나치게 의존하는 경우 또는 너무 많은 파라미터를 가진 경우 이 함수는 해당 객체에 결합되게 된다. 다른 상황에서 이 함수를 사용하기가 매우 어렵다는 뜻이다.
파급효과: 너무 가깝게 붙어 있게 되면 두 부분 중 하나를 변경하면 다른 부분에도 영향을 미친다.
낮은 수준의 추상화: 두 함수가 너무 가깝게 관련되어 있으면 서로 다른 추상화 레벨에서 문제를 해결하기 어렵기 때문에 관심사가 분리되어 있다고 보기 어렵다.

경험상 잘 정의된 소프트웨어는 높은 응집력과 낮은 결합력을 갖는다.

### 개발 지침 약어

DRY(Do not Repeat Yourself) OAOO(Once and Only Once) 자명한 원리로서 중복을 반드시 피해야한다. 코드에 있는 지식은 단 한번 단 한 곳에 정의되어야 한다. 코드를 변경하려고 할 때 수정이 필요한 곳은 단 한군데만 있어야 한다.

코드 중복의 부정적 영향

오류가 발생하기 쉽다: 어떤 로직이 코드 전체에 여러 번 반복되어 있는데 수정을 한다고 해보자. 이 때 인스턴스의 하나라도 빠뜨리면 버그가 발생할 것이다.
비용이 비싸다: 한 번 정의했을 때보다 여러 곳에서 정의했을 때보다 여러 곳에서 정의했을 경우 변경하는 데 더 많은 시간이 소요된다.
신뢰성이 떨어진다: 문맥상 여러 코드를 변경해야하는 경우 사람이 모든 인스턴스의 위치를 기억해야 한다.

YAGNI(You Ain't Gonna Need it) 과잉 엔지니어링을 하지 않기 위해 솔루션 작성 시 계속 염두에 두어야 하는 원칙이다.
오직 현재의 요구사항을 잘 해결하기 위한 소프트웨어를 작성하고 가능한 나중에 수정하기 쉽도록 작성하는 것이다.

KIS(keep It Simple) 소프트웨어 컴포넌트를 설계할 때 과잉 엔지니어링을 피해야 한다. 문제를 올바르게 해결하는 최소한의 기능을 구현하고 필요한 것 이상으로 솔루션을 복잡하게 만들지 않도록 해야 한다. 디자인이 단순할수록 유지보수가 편하다.

EAFP(Easier to Ask Forgiveness than Permission)는 허락보다는 용서를 구하는 것이 쉽다. LBYL(Look Before You Leap) 도약하기 전 살피라는 뜻이다.

EAFP는 일단 코드를 실행하고 실제 동작하지 않을 경우에 대응한다는 뜻이다. LBYL 반대이다. 예를 들어 파일을 사용하기 전에 먼저 파일을 사용할 수 있는지 확인하는 것이다. 파이썬은 EARP 방식으로 만들어졌으며 여러분도 그렇게 할 것을 권한다.

## 컴포지션과 상속

상속과 관련해 개발자들이 가장 많이 사용하는 기능은 코드 재사용이다. 상속의 단점은 결합력이 높아진다.

### 상속이 좋은 경우

파생 클래스를 만드는 것은 양날의 검이 될 수 있으므로 주의해야 한다. 한편으로는 부모 클래스의 메서드를 공짜로 전수 받을 수 있는 장점이 있지만 그러나 다른 한편으로 모든 것을 새로운 클래스로 가져왔기 때문에 새로운 정의에 너무 많은 기능을 추가하게 되는 단점도 있다.
상속의 좋은 예: 클래스의 기능을 그대로 물려받으면서 추가 기능을 더하려는 경우 또는 특정 기능을 수정하려는 경우, 인터페이스 정의, 예외
인터페이스 방식을 강제하고자 할 때 기본 추상 클래스를 만들고 이 클래스를 상속하는 하위 클래스에서 적절한 구현을 하도록 하는 것이다.
모든 예외는 Exceotion에서 상속받은 클래스이다.

### 상속 안티패턴

상속을 올바르게 사용하면 객체를 전문화하고 기본 객체에서 출발하여 세부적인 추상화를 할 수 있다. 데이터 구조 자체를 객체로 만드는 경우

```python
import collections
import datetime

class TransactionalPolicy(collections.UserDict):
    def change_in_policy(self, customer_id,**new_policy_data):
        self[customer_id].update(**new_policy_data)

policy = TransactionalPolicy({"Client001":{"fee":1000.0,"expiration_date":datetime.datetime(2020,1,3)}})
policy["Client001"]
policy.change_in_policy("Client001",expiration_date=datetime.datetime(2020,1,4))
policy["Client001"]

dir(policy)
```

위 코드 디자인의 문제점 계층구조가 잘못된 것이다. 클래스의 이름만 보고 직관적으로 딕트 형식이라는 것을 알아차리기 힘들다. 다른 문제는 결합력의 문제가 있다. TransactionalPolicy 이 클래스에 pop이나 기타 불 필요한 메서드가 포함되어 있다.
아래의 코드가 올바르게 리팩토링 된 코드이다.

```python
class TransactionalPolicy:
    def __init__(self,policy_data,**extra_data):
        self._data = {**policy_data,**extra_data}
    def change_in_policy(self, customer_id,**new_policy_data):
        self._data[customer_id].update(**new_policy_data)
    def __getitem__(self,customer_id):
        return self._data[customer_id]
    def __len__(self):
        return len(self._data)
```

### 파이썬의 다중상속

다중상속은 양날의 검이다. 어떤 경우에는 매우 유익할 수도 있다. 명확하게 말하면 다중 상속에 문제가 있는 것은 아니다. 유일한 문제는 올바르게 구현되지 않은면 문제가 커진다는 것이다.
두 개 이상의 클래스를 확장하고 해당 클래스들이 모두 하나의 같은 기본 클래스를 확장한 경우 맨 아래 클래스가 최상위 클래스에서 오는 메서드를 해결하는 방법은 여러가지가 있다. 문제는 이러한 구현 중 어느 것이 사용되는가이다.

파이썬은 C3 linearization 또는 MRO 라는 알고리즘을 사용하여 문제를 해결한다.

믹스인은 코드를 재사용하기 위해 일반적인 행동을 캡슐화해놓은 기본 클래스이다. 보통은 다른 클래스와 함께 믹스인 클래스를 다중 상속하여 믹스인에 있는 메서드나 속성을 사용한다.

## 함수와 메서드의 인자

### 파이썬의 함수 인자 동작방식

파이썬의 첫 번째 규칙은 모든 인자가 값에 의해 전달된다는 것이다.

```python
def function(arg):
    arg += "in function"
    print(arg)

immutable = "hello"
function(immutable)
mutable = list("hello")
immutable
function(mutable)
mutable
```

함수 인자를 변경하지 않아야 한다. 최대한 함수에서 발생할 수 있는 부작용을 회피하라

파이썬은 가변 인자를 사용할 수 있다. 가변 인자를 사용하려면 해당 인자를 패킹할 변수의 이름 앞에 별표(*)를 사용한다. 패킹 기법의 장점은 다른 방향으로도 동작한다는 것이다. 리스트의 값을 각 위치별로 변수에 언패킹할 수도 있다.

이중별표(**) 키워드를 인자에 사용할 수 있다. 딕트에 이중 별표를 사용하여 함수에 전달하면 파라미터의 이름으로 키를 사용하고 파라미터의 값으로 딕트의 값을 사용한다.

### 함수 인자의 개수

함수에 너무 많은 인자를 사용하는 경우에 대안으로는 구체화가 있다. 전달하는 모든 인자를 포함하는 새로운 객체를 만드는 것이다. 파이썬의 특정 기능을 사용하는 것이다. 가변 인자나 키워드 인자를 사용하여 동적 서명을 가진 함수를 만든다.

함수 인자와 결합력: 함수 서명의 인수가 많을수록 호출자 함수와 밀접하게 결합될 가능성이 커진다. 함수가 제대로 동작하기 위해 너무 많은 파라미터가 필요한 경우 코드의 나쁜냄새라고 생각하면 된다.

많은 인자를 취하는 작은 함수의 서명: 파라미터 그룹핑 혹은 모든 파라미터가 관련된 하나의 객체만 인자로 받는 것 등이 있다.
인자가 많은데 별표나 이중 별표를 사용하면 다 이해하기 어려운 상황을 만들 수 있다. 왜냐하면 서명을 잃어버린다는 것과 가독성을 거의 상실한다는 것 때문이다. 